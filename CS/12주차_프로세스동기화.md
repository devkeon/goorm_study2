# 프로세스 동기화

## IPC (Inter-Process Communication)
>### IPC란?
> - 프로세스끼리 데이터를 주고 받는 통신 방법
> - 스레드-스레드 통신은 쉬움


- 공유 메모리 or 공유 파일 이용한 통신
  - 가장 원시적 방법. 프로세스끼리 데이터를 주고 받는 방법을 알아서 결정해야함


- 파이프 이용 통신
  - 한 컴퓨터 내에서 일어날 때 많이 사용. OS가 제공하는 통신 기법으로 보통 부모-자식 프로세스 간 통신에 이용


- 소켓 이용 통신
  - 컴퓨터-컴퓨터가 네트워크로 연결된 경우의 통신에 사용되는 수단.(같은 컴퓨터 내에서도 가능은 하나 파이프 이용 통신과 비교하면 시스템 자원도 많이 사용하고 초기화할 내용도 많음)

### 통신 작업에 따른 분류
- **양방향 통신 (Duplex)**: 데이터를 양쪽 방향으로 동시에 전송 가능한 구조 ex) 소켓 이용 통신
- **반양방향 통신 (Half Duplex)**: 양쪽 전송 가능하지만 동시에 전공은 불가능하고 특정 시점에 한쪽 방향으로만 전송 가능
- **단방향 통신 (Simplex)**: 한쪽 방향으로만 데이터 전송 가능 구조. ex) 공유 메모리나 공유 파일 & 파이프 통신 해당

### 통신 구현 방식에 따른 분류
- 대기가 있는 통신 -> 동기화 통신, receiver 측은 데이터 도착까지 자동으로 대기 상태 ex) 파이프, 소켓
- 대기가 없는 통신 -> 비동기화 통신, 동기화 자원x, **바쁜 대기** 사용하여 직접 확인. ex) 공유 메모리, 파일

> - 바쁜 대기(Busy Waiting)
    >  - receiver는 언제 sender가 보낼지 모르므로 계속 점검하는 것 ex) loop
>  - 그러나 자원이 낭비됨

### 파일 이용 통신
- 파일 오픈
  - 파일이 있는지, 쓰기 권한이 있는지 확인, file descriptor 사용
- 파일 쓰기 또는 읽기
  - 쓰기 혹은 읽기 연산은 항상 file descriptor를 사용한다.
- 파일 닫기
  - close() 함수 이용해 닫음
>OS 입장에서는 저장장치 데이터를 읽고 쓰는 것도 IPC이다.
> 부모-자식 통신에서 많이 사용되고 OS가 동기화를 제공하지는 않는다. 알아서 동기화 (ex. wait()) 이용해 기다렸다가 작업을 시작한다.

### 파이프 이용 통신
- 파일 입출력 같이 open()함수로 descriptor 얻어 close()로 끝냄
  - 양방향 통신 시 파이프 2개 필요 (파이프는 반이중 통신 방식)
- 동기화 지원. 바쁜 대기 필요 x

파이프는 두가지 파이프로 나뉜다.

- **Anonymous Pipe (이름 없는 파이프)**: 일반적 파이프, 부모-자식 같은 통신할 프로세스를 명확히 아는 통신에 사용. 
- **Named Pipe (이름 있는 파이프)**: 이름이 있는 FIFO 파일을 이용해서 통신 프로세스가 명확하지 않은 통신에 사용.

### 소켓 이용 통신
- 포트 번호를 사용해 통신.
- 하나의 포트에 여러 클라이언트 연결 위해 소켓 필요.
> **포트**: 한 컴퓨터 내에서 네트워크를 사용하는 각 프로세스의 구분 번호


<br/>

IPC에 대해 이쯤에서 살펴보자. 그런데 IPC랑 동기화랑 무슨 상관일까? 우선 동기화의 개념에 대해 살펴보자.

---
## 동기화란?

### 동기화의 의미
- 프로세스는 독립적이나 여러 프로세스가 데이터를 주고받으며 협력하여 실행될 수 있다.(IPC를 통해)
- 이렇게 협력적으로 실행되는 프로세스들은 아무렇게나 동시에 실행해서는 안된다.
- 프로세스 동기화란 프로세스들 사이에 수행 시기를 맞추는 것을 의미한다.

> **수행 시기를 맞추는 것이란..** <br/>
> **실행 순서 제어**: 프로세스를 올바른 순서대로 실행하기 <br/>
> **상호 배제**: 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

즉, 동기화에는 실행 순서 제어를 위한 동기화가 있고, 상호 배제를 위한 동기화가 있다.

## 실행 순서 제어를 위한 동기화
예를 들어 Write 프로세스와 Read 프로세스가 동시에 실행중이라 하자. 두 프로세스 모두 같은 txt 파일에 접근한다. 이 두 프로세스는 아무 순서대로 실행되어서는 안된다.
Write 프로세스 실행이 끝나야 비로소 Read 프로세스를 실행해야 한다. txt 값이 다 쓰이기 전에 Read 프로세스를 실행하면 올바른 실행 순서가 아니다. 이렇게 프로세스를 올바른 순서대로
실행하는 것이 실행 순서 제어를 위한 동기화이다.

## 상호 배제를 위한 동기화
제일 중요하다고 할 수도 있다.

이를 이해 하려면 공유 자원과 임계구역에 대해 먼저 알아야한다.

### 공유 자원
- 공동으로 이용한느 변수, 메모리, 파일 등

### 임계 구역
- 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역
- 프로세스들이 동시에 작업하면 안되는 영역이다.

### 경쟁 조건 (Race Condition)
- 임계 구역은 두개 이상의 프로세스가 동시에 실행되면 안되는 영역이지만 동시에 임계 구역 코드를 실행하는 것을 race condition 이라고 한다.

이와 관련된 고전적인 문제가 바로 생산자-소비자 문제이다.

## 생산자-소비자 문제

생산자-소비자 문제란 생산자 process와 소비자 process가 있다고 가정하자. 생산자는 물건을 생산해 버퍼에 넣고 소비자는 버퍼에서 물건을 가져온다.

![](https://velog.velcdn.com/images%2Fcheal3%2Fpost%2F121b3f13-1abd-45c8-be90-21709fbc0695%2Fimage.png)

sum은 버퍼에 들어있는 총 물건의 수를 의미한다.

1. 생산자가 버퍼에 물건을 넣는다. 그러나 sum = sum + 1이 실행되기 전이다.
2. 소비자 프로세스에서 물건을 뺀다. 여기도 마찬가지로 sum = sum - 1이 실행 되기 전이다.
3. 이제 동시에 sum 값에 접근한다. 논리적으로 보면 연산 후의 sum 값은 3이어야 하지만 생산자 프로세스는 sum = sum - 1 이 실행되기 전이므로 sum = 3 값을 불러와서 sum = sum + 1 연산을 실행한다.
따라서 sum = 4가 된다.
4. 마찬가지로 소비자 프로세스에서도 sum + 1 전의 sum 값을 불러왔기 때문에 sum 값을 3을 불러오고 연산 후에 sum = 2가 된다.

-> 접근하는 타이밍이 맞지 않아서 발생하는 문제이다.

이러한 임계 구역 문제를 해결하기 위한 조건이 있다.

## 임계 구역 문제 해결 조건

### 상호 배제 (mutual exclusion)
- 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.

### 한정 대기 (bounded waiting)
- 한 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 임계 구역에 들어올 수 있어야 한다. 즉, 무한히 대기하지 않아야 한다.

### 진행의 융통성
- 한 프로세스가 다른 프로세스의 진행을 방해해서는 안된다.

<br/>
<br/>

참고 문헌: 

조성호. 쉽게 배우는 운영체제 2판. 출판지:한빛아카데미, 2023.01.30

강민철. 혼자 공부하는 컴퓨터+운영체제. 출판지:한빛아카데미, 2023.02.15

