
# 프로세스 상태


프로세스가 생성되고 종료되기까지 프로세스는 여러 상태를 거치게 됩니다. 운영체제는 이러한 프로세스의 상태를 PCB에 기록하여 관리합니다.

프로세스의 상태에 대해서는 2-model, 5-model, 7-model 다이어그램으로 나타낼 수 있는데, 여기서는  5-model을 을 기준으로 설명합니다.

![https://user-images.githubusercontent.com/59963677/139288242-13e5faa3-9363-4387-8e4f-fa4f85af718a.png](https://user-images.githubusercontent.com/59963677/139288242-13e5faa3-9363-4387-8e4f-fa4f85af718a.png)

- 생성 상태(New) :  프로세스를 생성 중인 상태. 이제 막 메모리에 적재되어 PCB를 할당받은 상태를 말합니다. 생성 상태를 거쳐 실행할 준비가 완료된 프로세스는 곧바로 실행되지 않고 준비 상태가 되어 CPU의 할당을 기다립니다.

- 준비 상태(Ready) : 기회가 주어지면 수행할 준비가 되어 있는 상태. 당장이라도 CPU를 할당받아 실행할 수 있지만, 아직 자신의 차례가 아니기에 기다리고 있는 상태입니다. 준비 상태 프로세스는 차례가 되면 CPU를 할당받아 실행 상태가 됩니다.
    
    (준비 상태인 프로세스가 실행 상태로 전환되는 것을 디스패치 *dispatch* 라고 합니다.)
    

- 실행 상태(Running) : CPU를 할당받아 실행 중인 상태. 할당된 시간을 모두 사용하여 타이머 인터럽트가 발생하면 다시 준비 상태가 됩니다. 혹은 실행 도중 입출력장치를 사용하여 입출력장치의 작업이 끝날때까지 기다려야 한다면 대기 상태가 됩니다.

- 대기 상태(Blocked/Waiting) : 실행 도중 입출력장치의 작업이 끝날 때까지 기다려야하는 상태. 입출력 작업이 완료되면 해당 프로세스는 다시 준비 상태가 되어 CPU 할당을 기다립니다.

- 종료 상태(Terminated) : 프로세스가 종료된 상태. 운영체제는 PCB와 프로세스가 사용한 메모리를 정리합니다.

<br>

# 프로세스 계층 구조



프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있습니다. 이때 새 프로세스를 생성한 프로세스를 부모 프로세스 *parent preocess* , 부모 프로세스에 의해 생성된 프로세스를 자식 프로세스 *child process* 라고 합니다. 
생성된 자식 프로세스 또한 새로운 자식 프로세스를 만들 수 있으며, 부모 프로세스와 자식 프로세스는 엄연히 다른  별개의 프로세스이기 때문에 각기 다른 PID를 가집니다.

<br>

![Untitled](https://oopy.lazyrockets.com/api/v2/notion/image?src=https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa6750cb-a51e-4ee6-801e-45c47a8fcbcb/Untitled.png&blockId=fe5611c5-3b01-4cc6-85c9-a2928e419b41)

운영체제는 프로세스가 프로세스를 낳는 계층적인 구조로 프로세스들을 관리합니다. 컴퓨터가 부팅될 때 실행되는 최초의 프로세스가 자식 프로세스들을 생성하고, 이 자식 프로세스들이 새로운 프로세스를 낳은 형식으로 여러 프로세스가 동시에 실행됩니다. 이 과정은 트리 구조를 띄게되고, 이것을 **프로세스 계층 구조**라고 합니다.

> 최초의 프로세스 ?
>
>주로 유닉스 운영체제에서는 init, 리눅스 운영체제에서는 systemd, macOS에서는 launchd 를 최초의 프로세스라고 합니다. 최초의 프로세스의 PID는 항상 1 이며, 모든 프로세스 최상단에 있는 부모 프로세스입니다.
> 
> 
> ![Untitled](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2Fed2e4ebd-df5d-47b8-ad3e-5e84e865040b%2Fc8eef431-1f61-4ff2-ba14-28cf85926abf%2FUntitled.png?table=block&id=e0855fce-612b-4a9e-a56a-8c587e7e65a3&spaceId=38552da6-340d-42c1-a9a1-b181ff331f03&width=1290&userId=9ba9e90d-cd15-494a-9671-a41d7bd156ba&cache=v2)
> 

<br>

# 프로세스 생성 기법



부모 프로세스는 시스템 호출 *system call* 을 통해 자식 프로세스를 만들어냅니다. 

부모 프로세스는 **fork** 를 통해 자신의 복사본을 자식 프로세스로 생성하고, 만들어진 복사본(자식 프로세스)은 **exec**를 통해 자신의 메모리 공간을 다른 프로그램으로 교체합니다.

fork와 exec가 시스템 호출에 해당합니다.

<br>

- fork() : Linux/UNIX 환경에서 새로운 프로세스를 만드는 시스템 콜 함수입니다. 생성된 자식 프로세스는 부모 프로세스의 데이터와 프로그램이 완전 복사가 되어 똑같은 프로그램을 수행하는 프로세스가 됩니다.


<img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F38552da6-340d-42c1-a9a1-b181ff331f03%2Fd4340dc1-1f2e-4d58-a357-3b486a406d37%2FUntitled.png?table=block&id=10fa93af-dfa2-4bf3-aca5-f8dab455a08b&spaceId=38552da6-340d-42c1-a9a1-b181ff331f03&width=720&userId=9ba9e90d-cd15-494a-9671-a41d7bd156ba&cache=v2" width="500"/>

<br>

- exec() : Linux/UNIX 환경에서 프로세스를 새로운 프로그램을 실행하는 프로세스로 대체하는 시스템 콜 함수입니다. 현재 프로세스의 프로그램 코드를 새로운 프로그램 코드로 바꿔줍니다. 이로 인하여 프로그램 코드, 메모리, 파일 등 프로세스 자원이 새로 바뀌게 됩니다.

<img src="https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F38552da6-340d-42c1-a9a1-b181ff331f03%2Fbf312386-8706-47fc-9fd5-b71ccc3442d5%2FUntitled.png?table=block&id=220026cf-fc32-49ea-9a58-d34e8b47ac97&spaceId=38552da6-340d-42c1-a9a1-b181ff331f03&width=1050&userId=9ba9e90d-cd15-494a-9671-a41d7bd156ba&cache=v2" width="600"/>

<br>

부모 프로세스가 fork()를 통해 자식 프로세스를 생성하고 자식 프로세스에서 exec()를 통해 새로운 프로그램을 돌리게 됩니다. 만약 자식 프로세스에서 exec() 를 호출하지 않는다면, 이 경우에는 부모 프로세스와 자식 프로세스는 같은 코드를 병렬적으로 실행하는 프로세스가 됩니다. 


<br><br><br>

참고

혼자 공부하는 컴퓨터구조 + 운영체제

[[운영체제] 프로세스 생성과 소멸](https://latter2005.tistory.com/105)